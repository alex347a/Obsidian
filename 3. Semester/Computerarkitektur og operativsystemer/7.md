Operating systems are made to complete basic tasks for the user
### Overview of operating system service
![[Pasted image 20251107082417.png]]
### CLI (Command Line Interface)
![[Pasted image 20251107082513.png]]
### GUI (Graphical User Interface)
![[Pasted image 20251107082526.png]]
![[Pasted image 20251107082644.png]]
### System call
![[Pasted image 20251107082650.png]]
### API (Application Programming Interface)
![[Pasted image 20251107082925.png]]
The kernel cannot be directly used by the user, only the user mode can be used to invoke a series of kernel commands
### Parameter transfer for system calls
![[Pasted image 20251107082940.png]]
There are 3 ways to transfer:
1. Register directly has limited space but is the fastest form of memory.
2. Register indirectly via table.
3. Stack.
#### Examples of system calls
![[Pasted image 20251107083334.png]]
#### Example of C-library
![[Pasted image 20251107083357.png]]
### Single-tasking OS (example of MS-DOS)
![[Pasted image 20251107083542.png]]
This was used in the 80's

### Multi-tasking OS (example of FreeBSD)
![[Pasted image 20251107083555.png]]
### Links and loader
![[Pasted image 20251107083854.png]]
The compiler turns the source code into an object file.
The linker links multiple object files and turns it into an executable file.
The loader loads the binary file to be run on the CPU. Only after the loader, an address will be assigned to the executable file in the memory.
Dynamically linked libraries are instead loaded on runtime, so if you have things you don't actually need to use it won't use up space in the memory even though it is included somewhere in the code.
### Virtual machine
![[Pasted image 20251107084154.png]]
### Monolithic structure (e xample UNIX
![[Pasted image 20251107084535.png]]
