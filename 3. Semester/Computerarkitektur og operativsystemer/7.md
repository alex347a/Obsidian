Operating systems are made to complete basic tasks for the user
### Overview of operating system service
![[Pasted image 20251107082417.png]]
### CLI (Command Line Interface)
![[Pasted image 20251107082513.png]]
### GUI (Graphical User Interface)
![[Pasted image 20251107082526.png]]
![[Pasted image 20251107082644.png]]
### System call
![[Pasted image 20251107082650.png]]
### API (Application Programming Interface)
![[Pasted image 20251107082925.png]]
The kernel cannot be directly used by the user, only the user mode can be used to invoke a series of kernel commands
### Parameter transfer for system calls
![[Pasted image 20251107082940.png]]
There are 3 ways to transfer:
1. Register directly has limited space but is the fastest form of memory.
2. Register indirectly via table.
3. Stack.
#### Examples of system calls
![[Pasted image 20251107083334.png]]
#### Example of C-library
![[Pasted image 20251107083357.png]]
### Single-tasking OS (example of MS-DOS)
![[Pasted image 20251107083542.png]]
This was used in the 80's

### Multi-tasking OS (example of FreeBSD)
![[Pasted image 20251107083555.png]]
### Links and loader
![[Pasted image 20251107083854.png]]
The compiler turns the source code into an object file.
The linker links multiple object files and turns it into an executable file.
The loader loads the binary file to be run on the CPU. Only after the loader, an address will be assigned to the executable file in the memory.
Dynamically linked libraries are instead loaded on runtime, so if you have things you don't actually need to use it won't use up space in the memory even though it is included somewhere in the code.
### Virtual machine
![[Pasted image 20251107084154.png]]
### Monolithic structure (example of UNIX)
![[Pasted image 20251107084535.png]]
Not a lot of overhead, so it's very efficient, but difficult to upgrade.
### Monolithic plus modular (example of Linux)
![[Pasted image 20251107084652.png]]
Modular meaning they are less dependant on each other.
### Layered structure (example of MULTICS the forerunner of UNIX)
![[Pasted image 20251107084710.png]]
It's easy to diagnose a problem in a layered structure by starting with the outermost layer and moving in a layer when you are sure the layer doesn't have a problem. The downside is the communication efficiency is quite poor, because you have to travel through a lot of layers to talk with the innermost layer from the outermost layer.
### Microkernel (example of MACH)
![[Pasted image 20251107085314.png]]
### Example of Solaris
![[Pasted image 20251107085432.png]]
### Hybrid systems MacOS and iOS
![[Pasted image 20251107085601.png]]
### Darwin
![[Pasted image 20251107091054.png]]
### Hybrid systems: iOS
![[Pasted image 20251107091057.png]]
### Hybrid systems: Android
![[Pasted image 20251107091101.png]]
### A process
![[Pasted image 20251107091022.png]]
Heap is dynamically allocated at runtime, stacks stores the temporary data for the parameters of the functions.
### Diagram of proces states
![[Pasted image 20251107091250.png]]
This is a state-machine
### PCB (Process Control Block)
![[Pasted image 20251107091417.png]]
A CPU core can only do one operation at a time, so if the process has to wait the CPU executes a different ready operation and the waiting process values are stored in the PCB as the process state. 
The process number is an identifier.
The program counter keeps track of which process to execute next.
The registers are the memory.
### Scheduling queues
![[Pasted image 20251107091955.png]]
### Queueing diagram
![[Pasted image 20251107092159.png]]
Each process on the cpu cannot be longer than the time slice (for example 10 milliseconds).
### Context switch
![[Pasted image 20251107092343.png]]
You can interweave different operations using a context switch and PCBs, so you can execute two process on the same CPU core.
### Interprocess communication models
![[Pasted image 20251107092505.png]]
You can either:
1. Share messages by message passing, which stores messages in the message queue (smaller overhead)
2. Share memory