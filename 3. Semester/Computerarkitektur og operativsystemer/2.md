### Von Neumann Architecture
The von Neumann architecture is the fundamental concept of computer design based on the ability to store program instructions and the data they operate on in the same memory. This replaced earlier machines that were built for a single purpose and required manual rewiring to program. The architecture consists of three main components: the central processing unit (CPU), memory, and input/output (I/O) interfaces.
![[2.1.png]]

### Central Processing Unit (CPU)
The CPU is the heart of the computing system and contains three main parts:
1. **Control Unit (CU):** Determines the order of instruction execution, controls operand retrieval, interprets instructions, and governs information flow by issuing control signals. Each operation from a control signal is a microoperation (MO).
    
2. **Arithmetic Logic Unit (ALU):** Performs all mathematical and Boolean operations.
    
3. **Registers:** Temporary storage locations for fast access to data and instructions being used. They are faster than memory because they are on the same chip as the CU. A CPU on a single chip is a microprocessor.

### Memory
The computer's memory stores program instructions and data. Two common types are:

1. **RAM (Random-Access Memory):** Stores data and general-purpose programs. It is temporary; its contents can be changed and are erased when power is off.
    
2. **ROM (Read-Only Memory):** Permanent memory used to store the initial boot-up instructions.
### Input/Output (I/O) Interfaces
I/O interfaces allow the computer's memory to receive information from input devices and send data to output devices. They also enable communication with the user and secondary storage devices like disk and tape drives.
### Buses
The components are connected by a collection of signal lines called a bus. The main buses are:

1. **Address Bus:** Identifies a memory location or an I/O device.
    
2. **Data Bus:** Bidirectional; sends data to or from a component.
    
3. **Control Bus:** Consists of signals that allow the CPU to communicate with memory and I/O devices. Each bus contains multiple wires for parallel transmission.

### Program Execution
Program execution involves the operating system controlling the three main components:

1. The program is loaded from secondary storage (like a disk) into memory via I/O interfaces.
    
2. The operating system schedules the CPU to execute the program.
    
3. The CPU fetches each instruction from memory into the Instruction Register (IR).
    
4. The instruction is decoded in the IR.
    
5. If needed, operands are fetched from memory or registers.
    
6. The instruction is executed.
    
7. Results are stored back in memory or registers.  
    This fetch-decode-execute cycle repeats for all instructions.

### Simple Microcomputer Design
A microcomputer is a computer whose CPU is a microprocessor. It is small and inexpensive, like a personal computer. The main components of a simple microcomputer are a CPU, a clock generator, a decoder, and memory modules.
![[2.2.png]]
### Memory Addressing
The example microcomputer has two memory modules (M0, M1), each containing 8 words of 8 bits each, for a total of sixteen 8-bit words. The 4-bit address bus can address all 16 locations. The three least significant address bits connect directly to the memory modules. The most significant bit (MSB) connects to the decoder's select line (S). When the MSB is 0, M0 is selected (addresses 0-7); when it is 1, M1 is selected (addresses 8-15).

### VHDL Structural View
The system's structure is described in VHDL, which declares components and connects them with signals. (INSERT FIGURE 2.3 HERE)

- The **declaration part** (before `begin`) defines the input/output ports for each component (CPU, RAM, DEC, CLK) and declares signals (like `M`) for interconnecting them.
    
- The **design part** (after `begin`) uses component instantiation statements to create instances of components and connect their ports to each other or to the declared signals via a `portmap`.
    

### RAM Behavioral View
The behavioral view of the RAM describes its function. (INSERT FIGURE 2.4 HERE)
- An array variable `memory` represents the 8x8 bit storage.
    
- A `while` loop checks if the RAM is selected (when `CS0` and `CS1` are both '1').
    
- A `case` statement handles read (`RW=0`) and write (`RW=1`) operations. A read copies data from the addressed memory location to the data bus. A write copies data from the data bus into the addressed memory location.
    
- A `process` with a `wait` statement suspends operation until a change on `CS0`, `CS1`, `DATA`, `ADDR`, or `RW` is detected.
    

### CPU Components
The main components of the CPU are: (INSERT FIGURE 2.5 HERE)
1. **Datapath:** Contains the Arithmetic Logic Unit (ALU) and various registers.
    
2. **Control Unit:** Governs the operation of the CPU.
    
3. **Register File:** A set of registers.  
    The CPU communicates with memory via the Memory Data Register (MDR) and Memory Address Register (MAR). The Program Counter (PC) holds the address of the next instruction to execute. The Instruction Register (IR) holds an instruction while it is being decoded and executed.
    

### Instruction Set
The example microcomputer uses a simple instruction set with a 2-bit opcode and operand fields. (INSERT FIGURE 2.6 HERE)
- **LOAD:** Loads a memory word into a register.
    
- **STORE:** Stores a register into a memory word.
    
- **ADDR:** Adds two registers and stores the result in a third register.
    
- **ADDM:** Adds a register and a memory word and stores the result in the register.
    

### Instruction Execution Phases
Instruction execution is divided into three main phases: (INSERT FIGURE 2.8 HERE)
1. **Instruction Fetch:** Retrieves an instruction from memory and stores it in the IR. The PC is incremented to point to the next instruction.
    
2. **Decode & Operand Fetch (decode_opfetch):** Decodes the instruction in the IR and fetches any required operands from memory or registers.
    
3. **Execute & Write Back (execute_opwrite):** Performs the operation and writes the result to the specified location (register or memory). Some instructions (like LOAD) complete after the decode_opfetch phase.
    

### Phase Control
A control process manages the sequence of these phases (inst_fetch -> decode_opfetch -> execute_opwrite -> inst_fetch...) using a state variable (`next_state`) triggered on the clock. (INSERT FIGURE 2.9 HERE)

### VHDL Process Descriptions
- **Fetch Phase (INSERT FIGURE 2.10 HERE):** Transfers PC to MAR and then to the address bus, requests a memory read, increments the PC, transfers the read data from the bus to MDR, and then from MDR to the IR.
    
- **Decode/Operand Fetch Phase (INSERT FIGURE 2.11 HERE):** Uses a `case` statement on the opcode (bits 7-6 of IR) to execute the specific routine for each instruction (e.g., initiating memory reads for LOAD/ADDM, memory writes for STORE, or setting up register operands for ADDR).
    
- **Execute/Write Phase (INSERT FIGURE 2.12 HERE):** Performs the core operation (e.g., addition via the `ADD` function when `add_op` is true) and writes the result to the destination register in the register file.