### Recap
![[Pasted image 20251107093046.png]]
Real-time CPU scheduling and algorithm evaluation will be introduced in lecture 9 instead.

### Multithreaded programming
![[Pasted image 20251107093130.png]]
They need their own registers, stack and PC, because they have different operations to execute simultaneously.
### Multithreaded server
![[Pasted image 20251107093331.png]]
Pros:
- Responsiveness.
- Resource Sharing.
- Economy.
- Scalability.
### Concurrency v.s. Parallelism
![[Pasted image 20251107093543.png]]
### Two types of parallelism
![[Pasted image 20251107093850.png]]
Data parallelism: you distribute the data over several cores
Task parallelism: you distribute the tasks, so each core does a different operation.
### Amdahl's law
![[Pasted image 20251107094037.png]]
$$
\text{speedup} \leq \frac{1}{S + \frac{1-S}{N}}
$$
Cons:
Find tasks that can be performed in parallel. The tasks need to take the same amount of time to complete. The data needs to be able to be split. You might have to wait for the output of something to use it as input for another task. Hard to test and debug.
### Multithreading models
#### Many-to-one
![[Pasted image 20251107094603.png]]
Keep in mind both of the threads are software threads, and the user only has access to the user threads.
#### One-to-one
![[Pasted image 20251107094752.png]]
#### Many-to-many
![[Pasted image 20251107094817.png]]
Keep in mind the 
#### Two-level-model
![[Pasted image 20251107094826.png]]