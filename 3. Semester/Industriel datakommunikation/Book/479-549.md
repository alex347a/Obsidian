### **The Link Layer and LANs - Introduction**
The link layer is responsible for transferring datagrams over a **single communication link** between adjacent nodes (hosts, routers, switches) along the end-to-end path.
**Key Questions for this Chapter:**
- How are network-layer datagrams encapsulated into link-layer frames?
- How are transmission conflicts on shared/broadcast links resolved?
- How does link-layer addressing work and how does it relate to network-layer (IP) addressing?
- What is the difference between a switch and a router?

**Two Fundamental Types of Link-Layer Channels:**
1. **Broadcast Channels:** Connect multiple hosts (e.g., wireless LANs, HFC cable access networks). Require a **Medium Access Control (MAC) protocol** to coordinate transmissions and avoid collisions.
2. **Point-to-Point Links:** Connect two individual nodes (e.g., a long-distance router link, a computer to an Ethernet switch). Coordination is simpler.

**Transportation Analogy:**
- **Tourist = Datagram**
- **Transportation Segment (e.g., limo, plane, train) = Link**
- **Transportation Company/Mode = Link-Layer Protocol**
- **Travel Agent = Routing Protocol**
#### **The Services Provided by the Link Layer**
Link-layer protocols can offer several key services:
- **Framing:** Encapsulates the network-layer datagram within a link-layer frame for transmission. The frame includes a data field (for the datagram) and header fields.
- **Link Access:** A **Medium Access Control (MAC) protocol** governs the rules for transmitting a frame onto the link. This is crucial for **multiple access** links where multiple nodes share a single broadcast channel.
- **Reliable Delivery:** Guarantees the movement of each datagram across the link without error, using acknowledgments and retransmissions. Often used for error-prone links (like wireless) but considered overhead for reliable wired links (like fibre).
- **Error Detection and Correction:** The transmitting node adds **error-detection bits** to the frame. The receiving node checks these bits to detect if bit errors have occurred during transmission. **Error correction** goes a step further by also determining and fixing the exact location of the errors.
#### **Where Is the Link Layer Implemented?**
The link layer is implemented in a combination of **hardware and software**, and is the point in the protocol stack where software meets hardware.
- **Hardware (Network Adapter / NIC):** The primary implementation. A dedicated chip (the network adapter or Network Interface Controller - NIC) handles most link-layer services in hardware:
    - Framing
    - Link access
    - Error detection
    - Signal transmission/reception
- **Software (Host CPU):** Implements higher-level link-layer functionality:
    - Assembling link-layer addressing information.
    - Activating the controller hardware.
    - Handling controller interrupts (e.g., frame received).
    - Passing datagrams up to the network layer. (INSERT FIGURE 6.2, TYPICAL HOST ARCHITECTURE, HERE)
### **Error-Detection and -Correction Techniques**
The link layer often provides services to detect and sometimes correct bit errors introduced during transmission. These techniques involve the sender adding extra **Error-Detection and -Correction (EDC)** bits to the data (D). The receiver uses these bits to determine if the received data (D') is error-free. (INSERT FIGURE 6.3, ERROR-DETECTION SCENARIO, HERE)

**Key Trade-off:** More robust error detection/correction techniques reduce the probability of **undetected errors** but incur a higher overhead (more EDC bits and more computation).
#### **Parity Checks**
**Single Parity Bit:**
- The sender adds one extra bit so that the total number of 1s in the `d+1` bits is either **even** (even parity) or **odd** (odd parity).
- The receiver counts the 1s. If the count doesn't match the expected parity (e.g., an odd number found with even parity), an error is detected. (INSERT FIGURE 6.4, ONE-BIT EVEN PARITY, HERE)
- **Limitation:** Can only detect an **odd number of bit errors**. If an even number of bits are flipped, the error goes **undetected**. This is problematic with burst errors.

**Two-Dimensional Parity:**
- A generalization that provides **error correction** capability.
- The `d` data bits are arranged in an `i x j` matrix.
- A parity bit is computed for each **row** and each **column**. The `i + j + 1` parity bits are sent as EDC. (INSERT FIGURE 6.5, TWO-DIMENSIONAL EVEN PARITY, HERE)
- **Capabilities:**
    - Can **detect and correct** any **single-bit error**. The intersection of the row and column with parity errors identifies the corrupted bit.
    - Can **detect (but not correct)** any combination of **two errors**.
#### **Forward Error Correction (FEC)**
- The ability of the receiver to **detect and correct errors** without needing the sender to retransmit the data.
- **Advantages:**
    - Reduces the number of retransmissions required.
    - Provides immediate correction, which is crucial for **real-time applications** (e.g., VoIP, video streaming) and links with **long propagation delays** (e.g., satellite, deep-space).
### **Checksumming Methods**
- **Concept:** The data (D) is treated as a sequence of k-bit integers. These integers are summed, and the resulting sum (or its complement) is used as the error-detection bits.
- **Internet Checksum:** Used at the **transport layer** (TCP, UDP) and **network layer** (IP header).
    - Data is treated as 16-bit integers.
    - The 1s complement of the sum is taken to form the checksum.
    - The receiver calculates the 1s complement of the sum (including the checksum); a result of all 0s indicates no error.
- **Characteristics:**
    - **Low Overhead:** Typically only 16 bits.
    - **Relatively Weak Protection:** Compared to CRC.
    - **Implemented in Software:** Used at the transport layer because it is simple and fast to compute in software on a host's CPU.
### **Cyclic Redundancy Check (CRC)**
CRC is a powerful error-detection technique widely used in the **link layer**, implemented in hardware on network adapters.
- **Operation:**
    1. Sender and receiver agree on a generator (G), an `r+1`-bit pattern.
    2. For data (D) of `d` bits, the sender selects `r` additional bits (R) such that the `d+r` bit pattern is **divisible by G** (using modulo-2 arithmetic).
    3. The receiver divides the received `d+r` bits by G. A **non-zero remainder indicates an error**.
- **Modulo-2 Arithmetic:** The core of CRC calculations. It is binary arithmetic without carries or borrows.
    - Addition and subtraction are both equivalent to the **bitwise XOR** operation.
    - Example: `1011 XOR 0101 = 1110`.
- **Calculating R (the CRC bits):** `R = remainder( (D • 2^r) / G )` (INSERT FIGURE 6.7, A SAMPLE CRC CALCULATION, HERE)
- **Strengths:**
    - Can detect all **burst errors** shorter than `r+1` bits.
    - Can detect any **odd number** of bit errors.
    - Very robust; a burst error longer than `r+1` bits is detected with a probability of `1 - 0.5^r`.

**Why Checksum at Transport, CRC at Link?**
- **Transport Layer:** Implemented in **software** on the host CPU. Needs a simple, fast algorithm like checksum.
- **Link Layer:** Implemented in **hardware** on the network adapter. Can perform the more complex but powerful CRC operations rapidly.
### **Multiple Access Links and Protocols**

This section addresses the problem of coordinating access to a **shared broadcast channel** (e.g., Ethernet, wireless LANs), where multiple nodes are connected to the same communication medium.
- **The Multiple Access Problem:** How to coordinate the transmissions of multiple sending and receiving nodes to a single, shared broadcast channel to avoid, or recover from, **collisions**.
- **Collision:** When two or more nodes transmit at the same time, their signals "collide," become intertwined, and the frames are **lost**, wasting channel bandwidth. (INSERT FIGURE 6.8, VARIOUS MULTIPLE ACCESS CHANNELS, HERE)

**Ideally, a multiple access protocol should have the following characteristics:**
1. **High throughput when only one node is active:** A single active node should be able to use the full channel rate, R bps.
2. **Fairness when multiple nodes are active:** When M nodes are active, each should get an average throughput of R/M bps.
3. **Decentralized:** No master node to create a single point of failure.
4. **Simple:** Inexpensive to implement.

**Three Broad Categories of Multiple Access Protocols:**
1. **Channel Partitioning Protocols:** Divide the channel (by time, frequency, or code) to avoid collisions.
2. **Random Access Protocols:** Nodes transmit at full rate, but if a collision occurs, they wait a random time before retransmitting.
3. **Taking-Turns Protocols:** Nodes take turns transmitting, coordinating in a structured way.

### **Channel Partitioning Protocols**
These protocols divide the broadcast channel's resources to avoid collisions entirely.
**1. Time-Division Multiplexing (TDM)**
- **Concept:** Time is divided into **frames**, and each frame is divided into **N time slots** (one for each of N nodes). Each node can only transmit during its assigned slot in each repeating frame.
- **Advantages:**
    - **Collision-free.**
    - **Perfectly fair:** Each node gets a dedicated rate of **R/N bps**.
- **Disadvantages:**
    - **Inefficient:** A node is limited to R/N bps **even if it is the only node with data to send**.
    - **Fixed Delay:** A node must always wait for its turn, even if the channel is idle. (INSERT FIGURE 6.9, TDM AND FDM EXAMPLE, HERE)

**2. Frequency-Division Multiplexing (FDM)**
- **Concept:** The channel's frequency spectrum is divided into **N different frequency bands**, each with a bandwidth of R/N. Each node is assigned its own dedicated frequency band.
- **Advantages & Disadvantages:** Shares the same pros and cons as TDM: collision-free and fair, but inefficient for a single active node (limited to R/N bps).

**3. Code Division Multiple Access (CDMA)**
- **Concept:** Assigns a **unique code** to each node. All nodes can transmit **simultaneously** over the entire frequency spectrum. A receiver can correctly decode a specific sender's data if it knows that sender's code, effectively filtering out other transmissions.
- **Use Cases:** Widely used in military systems (for anti-jamming) and in **cellular telephony**.
### **Random Access Protocols**
In random access protocols, a node transmits at the **full channel rate (R bps)** when it has data. If a **collision** occurs, the node waits a **random delay** before retransmitting. This avoids the channel waste of partitioning protocols when only one node is active.
#### **Slotted ALOHA**
This is a simple random access protocol with specific assumptions to make analysis easier.
**Assumptions:**
- Time is divided into equal **slots** (the size of one frame transmission time).
- Nodes are **synchronized** and can only start transmission at the beginning of a slot.
- All frames are the same size.
- Nodes can detect a collision before the slot ends.

**Protocol Operation:**
1. When a node has a new frame, it transmits at the beginning of the next slot.
2. If no collision occurs, the transmission is successful. The node is done.
3. If a collision occurs, the node detects it. The node then **retransmits the frame in each subsequent slot with probability `p`** until it is successful. (INSERT FIGURE 6.10, SLOTTED ALOHA OPERATION, HERE)

**Advantages:**
- **Single Active Node:** A single node can use the **full channel rate, R bps**.
- **Highly decentralized:** No central coordinator is needed.
- **Simple** to implement.

**Disadvantage: Efficiency**
- **Efficiency:** The long-run fraction of **successful slots** (slots where exactly one node transmits) when many nodes are active.
- **Analysis:** The maximum efficiency of slotted ALOHA is **1/e ≈ 0.37**.
- **Interpretation:** This means that at best, only **37% of the channel's capacity** is used for successful transmissions. The rest is wasted on **collisions (26%)** and **empty slots (37%)**.
