### **The Link Layer and LANs - Introduction**
The link layer is responsible for transferring datagrams over a **single communication link** between adjacent nodes (hosts, routers, switches) along the end-to-end path.
**Key Questions for this Chapter:**
- How are network-layer datagrams encapsulated into link-layer frames?
- How are transmission conflicts on shared/broadcast links resolved?
- How does link-layer addressing work and how does it relate to network-layer (IP) addressing?
- What is the difference between a switch and a router?

**Two Fundamental Types of Link-Layer Channels:**
1. **Broadcast Channels:** Connect multiple hosts (e.g., wireless LANs, HFC cable access networks). Require a **Medium Access Control (MAC) protocol** to coordinate transmissions and avoid collisions.
2. **Point-to-Point Links:** Connect two individual nodes (e.g., a long-distance router link, a computer to an Ethernet switch). Coordination is simpler.

**Transportation Analogy:**
- **Tourist = Datagram**
- **Transportation Segment (e.g., limo, plane, train) = Link**
- **Transportation Company/Mode = Link-Layer Protocol**
- **Travel Agent = Routing Protocol**
#### **The Services Provided by the Link Layer**
Link-layer protocols can offer several key services:
- **Framing:** Encapsulates the network-layer datagram within a link-layer frame for transmission. The frame includes a data field (for the datagram) and header fields.
- **Link Access:** A **Medium Access Control (MAC) protocol** governs the rules for transmitting a frame onto the link. This is crucial for **multiple access** links where multiple nodes share a single broadcast channel.
- **Reliable Delivery:** Guarantees the movement of each datagram across the link without error, using acknowledgments and retransmissions. Often used for error-prone links (like wireless) but considered overhead for reliable wired links (like fibre).
- **Error Detection and Correction:** The transmitting node adds **error-detection bits** to the frame. The receiving node checks these bits to detect if bit errors have occurred during transmission. **Error correction** goes a step further by also determining and fixing the exact location of the errors.
#### **Where Is the Link Layer Implemented?**
The link layer is implemented in a combination of **hardware and software**, and is the point in the protocol stack where software meets hardware.
- **Hardware (Network Adapter / NIC):** The primary implementation. A dedicated chip (the network adapter or Network Interface Controller - NIC) handles most link-layer services in hardware:
    - Framing
    - Link access
    - Error detection
    - Signal transmission/reception
- **Software (Host CPU):** Implements higher-level link-layer functionality:
    - Assembling link-layer addressing information.
    - Activating the controller hardware.
    - Handling controller interrupts (e.g., frame received).
    - Passing datagrams up to the network layer. (INSERT FIGURE 6.2, TYPICAL HOST ARCHITECTURE, HERE)
### **Error-Detection and -Correction Techniques**
The link layer often provides services to detect and sometimes correct bit errors introduced during transmission. These techniques involve the sender adding extra **Error-Detection and -Correction (EDC)** bits to the data (D). The receiver uses these bits to determine if the received data (D') is error-free. (INSERT FIGURE 6.3, ERROR-DETECTION SCENARIO, HERE)

**Key Trade-off:** More robust error detection/correction techniques reduce the probability of **undetected errors** but incur a higher overhead (more EDC bits and more computation).
#### **Parity Checks**
**Single Parity Bit:**
- The sender adds one extra bit so that the total number of 1s in the `d+1` bits is either **even** (even parity) or **odd** (odd parity).
- The receiver counts the 1s. If the count doesn't match the expected parity (e.g., an odd number found with even parity), an error is detected. (INSERT FIGURE 6.4, ONE-BIT EVEN PARITY, HERE)
- **Limitation:** Can only detect an **odd number of bit errors**. If an even number of bits are flipped, the error goes **undetected**. This is problematic with burst errors.

**Two-Dimensional Parity:**
- A generalization that provides **error correction** capability.
- The `d` data bits are arranged in an `i x j` matrix.
- A parity bit is computed for each **row** and each **column**. The `i + j + 1` parity bits are sent as EDC. (INSERT FIGURE 6.5, TWO-DIMENSIONAL EVEN PARITY, HERE)
- **Capabilities:**
    - Can **detect and correct** any **single-bit error**. The intersection of the row and column with parity errors identifies the corrupted bit.
    - Can **detect (but not correct)** any combination of **two errors**.
#### **Forward Error Correction (FEC)**
- The ability of the receiver to **detect and correct errors** without needing the sender to retransmit the data.
- **Advantages:**
    - Reduces the number of retransmissions required.
    - Provides immediate correction, which is crucial for **real-time applications** (e.g., VoIP, video streaming) and links with **long propagation delays** (e.g., satellite, deep-space).
### **Checksumming Methods**
- **Concept:** The data (D) is treated as a sequence of k-bit integers. These integers are summed, and the resulting sum (or its complement) is used as the error-detection bits.
- **Internet Checksum:** Used at the **transport layer** (TCP, UDP) and **network layer** (IP header).
    - Data is treated as 16-bit integers.
    - The 1s complement of the sum is taken to form the checksum.
    - The receiver calculates the 1s complement of the sum (including the checksum); a result of all 0s indicates no error.
- **Characteristics:**
    - **Low Overhead:** Typically only 16 bits.
    - **Relatively Weak Protection:** Compared to CRC.
    - **Implemented in Software:** Used at the transport layer because it is simple and fast to compute in software on a host's CPU.
### **Cyclic Redundancy Check (CRC)**
CRC is a powerful error-detection technique widely used in the **link layer**, implemented in hardware on network adapters.
- **Operation:**
    1. Sender and receiver agree on a generator (G), an `r+1`-bit pattern.
    2. For data (D) of `d` bits, the sender selects `r` additional bits (R) such that the `d+r` bit pattern is **divisible by G** (using modulo-2 arithmetic).
    3. The receiver divides the received `d+r` bits by G. A **non-zero remainder indicates an error**.
- **Modulo-2 Arithmetic:** The core of CRC calculations. It is binary arithmetic without carries or borrows.
    - Addition and subtraction are both equivalent to the **bitwise XOR** operation.
    - Example: `1011 XOR 0101 = 1110`.
- **Calculating R (the CRC bits):** `R = remainder( (D • 2^r) / G )` (INSERT FIGURE 6.7, A SAMPLE CRC CALCULATION, HERE)
- **Strengths:**
    - Can detect all **burst errors** shorter than `r+1` bits.
    - Can detect any **odd number** of bit errors.
    - Very robust; a burst error longer than `r+1` bits is detected with a probability of `1 - 0.5^r`.

**Why Checksum at Transport, CRC at Link?**
- **Transport Layer:** Implemented in **software** on the host CPU. Needs a simple, fast algorithm like checksum.
- **Link Layer:** Implemented in **hardware** on the network adapter. Can perform the more complex but powerful CRC operations rapidly.
### **Multiple Access Links and Protocols**

This section addresses the problem of coordinating access to a **shared broadcast channel** (e.g., Ethernet, wireless LANs), where multiple nodes are connected to the same communication medium.
- **The Multiple Access Problem:** How to coordinate the transmissions of multiple sending and receiving nodes to a single, shared broadcast channel to avoid, or recover from, **collisions**.
- **Collision:** When two or more nodes transmit at the same time, their signals "collide," become intertwined, and the frames are **lost**, wasting channel bandwidth. (INSERT FIGURE 6.8, VARIOUS MULTIPLE ACCESS CHANNELS, HERE)

**Ideally, a multiple access protocol should have the following characteristics:**
1. **High throughput when only one node is active:** A single active node should be able to use the full channel rate, R bps.
2. **Fairness when multiple nodes are active:** When M nodes are active, each should get an average throughput of R/M bps.
3. **Decentralized:** No master node to create a single point of failure.
4. **Simple:** Inexpensive to implement.

**Three Broad Categories of Multiple Access Protocols:**
1. **Channel Partitioning Protocols:** Divide the channel (by time, frequency, or code) to avoid collisions.
2. **Random Access Protocols:** Nodes transmit at full rate, but if a collision occurs, they wait a random time before retransmitting.
3. **Taking-Turns Protocols:** Nodes take turns transmitting, coordinating in a structured way.

### **Channel Partitioning Protocols**
These protocols divide the broadcast channel's resources to avoid collisions entirely.
**1. Time-Division Multiplexing (TDM)**
- **Concept:** Time is divided into **frames**, and each frame is divided into **N time slots** (one for each of N nodes). Each node can only transmit during its assigned slot in each repeating frame.
- **Advantages:**
    - **Collision-free.**
    - **Perfectly fair:** Each node gets a dedicated rate of **R/N bps**.
- **Disadvantages:**
    - **Inefficient:** A node is limited to R/N bps **even if it is the only node with data to send**.
    - **Fixed Delay:** A node must always wait for its turn, even if the channel is idle. (INSERT FIGURE 6.9, TDM AND FDM EXAMPLE, HERE)

**2. Frequency-Division Multiplexing (FDM)**
- **Concept:** The channel's frequency spectrum is divided into **N different frequency bands**, each with a bandwidth of R/N. Each node is assigned its own dedicated frequency band.
- **Advantages & Disadvantages:** Shares the same pros and cons as TDM: collision-free and fair, but inefficient for a single active node (limited to R/N bps).

**3. Code Division Multiple Access (CDMA)**
- **Concept:** Assigns a **unique code** to each node. All nodes can transmit **simultaneously** over the entire frequency spectrum. A receiver can correctly decode a specific sender's data if it knows that sender's code, effectively filtering out other transmissions.
- **Use Cases:** Widely used in military systems (for anti-jamming) and in **cellular telephony**.
### **Random Access Protocols**
In random access protocols, a node transmits at the **full channel rate (R bps)** when it has data. If a **collision** occurs, the node waits a **random delay** before retransmitting. This avoids the channel waste of partitioning protocols when only one node is active.
#### **Slotted ALOHA**
This is a simple random access protocol with specific assumptions to make analysis easier.
**Assumptions:**
- Time is divided into equal **slots** (the size of one frame transmission time).
- Nodes are **synchronized** and can only start transmission at the beginning of a slot.
- All frames are the same size.
- Nodes can detect a collision before the slot ends.

**Protocol Operation:**
1. When a node has a new frame, it transmits at the beginning of the next slot.
2. If no collision occurs, the transmission is successful. The node is done.
3. If a collision occurs, the node detects it. The node then **retransmits the frame in each subsequent slot with probability `p`** until it is successful. (INSERT FIGURE 6.10, SLOTTED ALOHA OPERATION, HERE)

**Advantages:**
- **Single Active Node:** A single node can use the **full channel rate, R bps**.
- **Highly decentralized:** No central coordinator is needed.
- **Simple** to implement.

**Disadvantage: Efficiency**
- **Efficiency:** The long-run fraction of **successful slots** (slots where exactly one node transmits) when many nodes are active.
- **Analysis:** The maximum efficiency of slotted ALOHA is **1/e ≈ 0.37**.
- **Interpretation:** This means that at best, only **37% of the channel's capacity** is used for successful transmissions. The rest is wasted on **collisions (26%)** and **empty slots (37%)**.
### **ALOHA**
**Pure ALOHA (Unslotted ALOHA)**
- **Operation:** A fully decentralized protocol. When a frame first arrives, the node **immediately transmits** it in its entirety.
- **Collision Handling:** If a collision occurs, the node **immediately retransmits the frame with probability `p`** after the transmission is complete. Otherwise, it waits one frame transmission time and tries again.
- **Vulnerability Period:** For a frame starting at time `t₀` to be successful, no other node can start transmitting in the interval `[t₀ - 1, t₀ + 1]`. This is a **2-unit time** window. (INSERT FIGURE 6.11, INTERFERING TRANSMISSIONS IN PURE ALOHA, HERE)
- **Efficiency:** The maximum efficiency of pure ALOHA is **1/(2e) ≈ 0.18**. This is **half the efficiency of slotted ALOHA**, which is the price paid for being completely unslotted and decentralized.
### **Carrier Sense Multiple Access (CSMA)**
CSMA protocols introduce two simple, polite rules to reduce the chance of collisions, inspired by human conversation:
1. **Carrier Sensing: "Listen before speaking."** A node listens to the channel (**senses the carrier**) before transmitting. If the channel is busy, it waits.
2. **Collision Detection: "If someone else starts talking at the same time, stop talking."** A node listens to the channel **while it is transmitting**. If it detects that another node's transmission is interfering (a collision), it **stops transmitting** immediately.

**Why Do Collisions Still Occur in CSMA?**
- Due to **channel propagation delay**. A signal takes time to travel across the medium.
- **Scenario:** Node B starts transmitting. Its signal hasn't reached Node D yet. Node D senses the channel as idle and starts transmitting, leading to a collision. (INSERT FIGURE 6.12, CSMA WITH COLLIDING TRANSMISSIONS, HERE)
### **CSMA with Collision Detection (CSMA/CD)**
This is the protocol used in **Ethernet**. It combines carrier sensing with collision detection to improve efficiency by not wasting time transmitting corrupted frames in full.
**CSMA/CD Operation:**
1. The adapter gets a datagram and prepares a frame.
2. If the channel is idle, it starts transmitting. If busy, it waits until idle.
3. **While transmitting,** the adapter monitors the channel for collisions.
4. If the entire frame is transmitted without a collision, the process is done.
5. If a collision is detected **during transmission**, the adapter **immediately aborts** the transmission. (INSERT FIGURE 6.13, CSMA WITH COLLISION DETECTION, HERE)
6. After aborting, the adapter waits a **random** amount of time before returning to step 2.

**Binary Exponential Backoff:**
- This is the algorithm used to determine the random wait time after a collision. It ensures stability by adapting the wait time based on how many collisions a frame has experienced.
- **Algorithm:** After the *n*th collision, the adapter chooses a value **K** at random from the set `{0, 1, 2, ..., 2ⁿ-1}`. The wait time is **K × 512 bit times**.
- **Effect:** The **more collisions** a frame experiences, the **larger the range** from which K is chosen. This helps to separate the retransmission attempts of colliding nodes.
- The exponent `n` is capped (at 10 for Ethernet), so the wait time doesn't grow infinitely.
### **CASE HISTORY: Norm Abramson and ALOHAnet**
- Norm Abramson designed the **ALOHAnet** in Hawaii in 1969 to solve the problem of packet switching over radio across mountainous islands.
- This was the first example of a radio packet network.
- The **pure ALOHA** protocol was developed for this network to handle collisions on the shared upstream channel.
- ALOHAnet's design later **inspired Bob Metcalfe**, who modified it to create the **CSMA/CD protocol** and, ultimately, **Ethernet**.
### **CSMA/CD Efficiency**
The efficiency of CSMA/CD (as used in Ethernet) is defined as the long-run fraction of time the channel is used for **successful frame transmissions** without collisions.
- **Efficiency Formula:** `Efficiency = 1 / (1 + 5 * d_prop / d_trans)`
    - **`d_prop`:** The **maximum propagation delay** for a signal to travel between the two farthest nodes.
    - **`d_trans`:** The **time to transmit a maximum-size frame**.
**Interpretation:**
- If **`d_prop → 0`**, efficiency approaches **1**. With no propagation delay, collisions are detected instantly, and no channel capacity is wasted.
- If **`d_trans` becomes very large**, efficiency approaches **1**. A single frame holds the channel for a long time, making productive use of it.
### **Taking-Turns Protocols**
These protocols aim to provide the high efficiency of a single active node using the full rate (R bps) while also providing fair, collision-free access when multiple nodes are active (each getting ~R/M bps).

**1. Polling Protocol:**
- **Operation:** A designated **master node** polls the other nodes in a round-robin fashion. It asks each node in turn if it has data to send, granting it permission to transmit up to a maximum number of frames.
- **Advantages:**
    - **Eliminates collisions and empty slots**, leading to high efficiency.
- **Disadvantages:**
    - **Polling Delay:** The time spent notifying nodes introduces latency.
    - **Single Point of Failure:** If the master node fails, the entire network fails.
    - **Example:** Bluetooth.

**2. Token-Passing Protocol:**
- **Operation:** A special frame called a **token** is passed from node to node in a fixed, circular order. A node can only transmit when it is holding the token.
- **Advantages:**
    - **Decentralized** (no master node).
    - **Highly efficient** and collision-free.
- **Disadvantages:**
    - **Token Loss:** If a node fails, the token can be lost, crashing the network.
    - **Token Holding:** A faulty or malicious node might hold the token indefinitely.
    - **Examples:** FDDI, IEEE 802.5 Token Ring.
### **DOCSIS: The Link-Layer Protocol for Cable Internet Access**
DOCSIS is the protocol used in cable internet access networks. It provides a fascinating **case study** because it combines elements from **all three classes** of multiple access protocols.
**Network Context:**
- The **Cable Modem Termination System (CMTS)** at the headend communicates with thousands of residential **cable modems**.
- **Downstream (CMTS → Modems):** A pure broadcast channel from a single sender (the CMTS), so no multiple access problem.
- **Upstream (Modems → CMTS):** A shared broadcast channel where multiple modems can transmit, requiring a multiple access protocol.

**How DOCSIS Works (Upstream Channel):** (INSERT FIGURE 6.14, DOCSIS UPSTREAM AND DOWNSTREAM, HERE)
1. **TDM-like Structure:** The upstream channel is divided into time intervals containing **mini-slots**.
2. **Centralized Allocation (Taking-Turns):** The CMTS sends a **MAP message** (downstream) to explicitly grant specific mini-slots to specific cable modems for data transmission. This **prevents collisions** for data frames.
3. **Random Access for Requests:** To tell the CMTS it has data to send, a modem transmits a **mini-slot-request frame** during a special set of mini-slots reserved for this purpose. These requests are sent using a **random access** method and **can collide**.
4. **Collision Handling:** Modems cannot sense the channel. They infer a collision if they don't receive a grant in response to their request. They then use **binary exponential backoff** to retransmit the request.

**Summary:** DOCSIS is a hybrid protocol using:
- **FDM** to create separate upstream/downstream channels.
- **TDM** to structure the upstream channel into mini-slots.
- **Taking-Turns** for collision-free data transmission via central allocation.
- **Random Access** with binary exponential backoff for initial bandwidth requests.
