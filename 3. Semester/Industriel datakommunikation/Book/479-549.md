### **The Link Layer and LANs - Introduction**
The link layer is responsible for transferring datagrams over a **single communication link** between adjacent nodes (hosts, routers, switches) along the end-to-end path.
**Key Questions for this Chapter:**
- How are network-layer datagrams encapsulated into link-layer frames?
- How are transmission conflicts on shared/broadcast links resolved?
- How does link-layer addressing work and how does it relate to network-layer (IP) addressing?
- What is the difference between a switch and a router?

**Two Fundamental Types of Link-Layer Channels:**
1. **Broadcast Channels:** Connect multiple hosts (e.g., wireless LANs, HFC cable access networks). Require a **Medium Access Control (MAC) protocol** to coordinate transmissions and avoid collisions.
2. **Point-to-Point Links:** Connect two individual nodes (e.g., a long-distance router link, a computer to an Ethernet switch). Coordination is simpler.

**Transportation Analogy:**
- **Tourist = Datagram**
- **Transportation Segment (e.g., limo, plane, train) = Link**
- **Transportation Company/Mode = Link-Layer Protocol**
- **Travel Agent = Routing Protocol**
#### **The Services Provided by the Link Layer**
Link-layer protocols can offer several key services:
- **Framing:** Encapsulates the network-layer datagram within a link-layer frame for transmission. The frame includes a data field (for the datagram) and header fields.
- **Link Access:** A **Medium Access Control (MAC) protocol** governs the rules for transmitting a frame onto the link. This is crucial for **multiple access** links where multiple nodes share a single broadcast channel.
- **Reliable Delivery:** Guarantees the movement of each datagram across the link without error, using acknowledgments and retransmissions. Often used for error-prone links (like wireless) but considered overhead for reliable wired links (like fibre).
- **Error Detection and Correction:** The transmitting node adds **error-detection bits** to the frame. The receiving node checks these bits to detect if bit errors have occurred during transmission. **Error correction** goes a step further by also determining and fixing the exact location of the errors.
#### **Where Is the Link Layer Implemented?**
The link layer is implemented in a combination of **hardware and software**, and is the point in the protocol stack where software meets hardware.
- **Hardware (Network Adapter / NIC):** The primary implementation. A dedicated chip (the network adapter or Network Interface Controller - NIC) handles most link-layer services in hardware:
    - Framing
    - Link access
    - Error detection
    - Signal transmission/reception
- **Software (Host CPU):** Implements higher-level link-layer functionality:
    - Assembling link-layer addressing information.
    - Activating the controller hardware.
    - Handling controller interrupts (e.g., frame received).
    - Passing datagrams up to the network layer. (INSERT FIGURE 6.2, TYPICAL HOST ARCHITECTURE, HERE)
### **Error-Detection and -Correction Techniques**
The link layer often provides services to detect and sometimes correct bit errors introduced during transmission. These techniques involve the sender adding extra **Error-Detection and -Correction (EDC)** bits to the data (D). The receiver uses these bits to determine if the received data (D') is error-free. (INSERT FIGURE 6.3, ERROR-DETECTION SCENARIO, HERE)

**Key Trade-off:** More robust error detection/correction techniques reduce the probability of **undetected errors** but incur a higher overhead (more EDC bits and more computation).
#### **Parity Checks**
**Single Parity Bit:**
- The sender adds one extra bit so that the total number of 1s in the `d+1` bits is either **even** (even parity) or **odd** (odd parity).
- The receiver counts the 1s. If the count doesn't match the expected parity (e.g., an odd number found with even parity), an error is detected. (INSERT FIGURE 6.4, ONE-BIT EVEN PARITY, HERE)
- **Limitation:** Can only detect an **odd number of bit errors**. If an even number of bits are flipped, the error goes **undetected**. This is problematic with burst errors.

**Two-Dimensional Parity:**
- A generalization that provides **error correction** capability.
- The `d` data bits are arranged in an `i x j` matrix.
- A parity bit is computed for each **row** and each **column**. The `i + j + 1` parity bits are sent as EDC. (INSERT FIGURE 6.5, TWO-DIMENSIONAL EVEN PARITY, HERE)
- **Capabilities:**
    - Can **detect and correct** any **single-bit error**. The intersection of the row and column with parity errors identifies the corrupted bit.
    - Can **detect (but not correct)** any combination of **two errors**.
#### **Forward Error Correction (FEC)**
- The ability of the receiver to **detect and correct errors** without needing the sender to retransmit the data.
- **Advantages:**
    - Reduces the number of retransmissions required.
    - Provides immediate correction, which is crucial for **real-time applications** (e.g., VoIP, video streaming) and links with **long propagation delays** (e.g., satellite, deep-space).
### **Checksumming Methods**
- **Concept:** The data (D) is treated as a sequence of k-bit integers. These integers are summed, and the resulting sum (or its complement) is used as the error-detection bits.
- **Internet Checksum:** Used at the **transport layer** (TCP, UDP) and **network layer** (IP header).
    - Data is treated as 16-bit integers.
    - The 1s complement of the sum is taken to form the checksum.
    - The receiver calculates the 1s complement of the sum (including the checksum); a result of all 0s indicates no error.
- **Characteristics:**
    - **Low Overhead:** Typically only 16 bits.
    - **Relatively Weak Protection:** Compared to CRC.
    - **Implemented in Software:** Used at the transport layer because it is simple and fast to compute in software on a host's CPU.
### **Cyclic Redundancy Check (CRC)**
CRC is a powerful error-detection technique widely used in the **link layer**, implemented in hardware on network adapters.
- **Operation:**
    1. Sender and receiver agree on a generator (G), an `r+1`-bit pattern.
    2. For data (D) of `d` bits, the sender selects `r` additional bits (R) such that the `d+r` bit pattern is **divisible by G** (using modulo-2 arithmetic).
    3. The receiver divides the received `d+r` bits by G. A **non-zero remainder indicates an error**.
- **Modulo-2 Arithmetic:** The core of CRC calculations. It is binary arithmetic without carries or borrows.
    - Addition and subtraction are both equivalent to the **bitwise XOR** operation.
    - Example: `1011 XOR 0101 = 1110`.
- **Calculating R (the CRC bits):** `R = remainder( (D • 2^r) / G )` (INSERT FIGURE 6.7, A SAMPLE CRC CALCULATION, HERE)
- **Strengths:**
    - Can detect all **burst errors** shorter than `r+1` bits.
    - Can detect any **odd number** of bit errors.
    - Very robust; a burst error longer than `r+1` bits is detected with a probability of `1 - 0.5^r`.

**Why Checksum at Transport, CRC at Link?**
- **Transport Layer:** Implemented in **software** on the host CPU. Needs a simple, fast algorithm like checksum.
- **Link Layer:** Implemented in **hardware** on the network adapter. Can perform the more complex but powerful CRC operations rapidly.
### **Multiple Access Links and Protocols**

This section addresses the problem of coordinating access to a **shared broadcast channel** (e.g., Ethernet, wireless LANs), where multiple nodes are connected to the same communication medium.
- **The Multiple Access Problem:** How to coordinate the transmissions of multiple sending and receiving nodes to a single, shared broadcast channel to avoid, or recover from, **collisions**.
- **Collision:** When two or more nodes transmit at the same time, their signals "collide," become intertwined, and the frames are **lost**, wasting channel bandwidth. (INSERT FIGURE 6.8, VARIOUS MULTIPLE ACCESS CHANNELS, HERE)

**Ideally, a multiple access protocol should have the following characteristics:**
1. **High throughput when only one node is active:** A single active node should be able to use the full channel rate, R bps.
2. **Fairness when multiple nodes are active:** When M nodes are active, each should get an average throughput of R/M bps.
3. **Decentralized:** No master node to create a single point of failure.
4. **Simple:** Inexpensive to implement.

**Three Broad Categories of Multiple Access Protocols:**
1. **Channel Partitioning Protocols:** Divide the channel (by time, frequency, or code) to avoid collisions.
2. **Random Access Protocols:** Nodes transmit at full rate, but if a collision occurs, they wait a random time before retransmitting.
3. **Taking-Turns Protocols:** Nodes take turns transmitting, coordinating in a structured way.

### **Channel Partitioning Protocols**
These protocols divide the broadcast channel's resources to avoid collisions entirely.
**1. Time-Division Multiplexing (TDM)**
- **Concept:** Time is divided into **frames**, and each frame is divided into **N time slots** (one for each of N nodes). Each node can only transmit during its assigned slot in each repeating frame.
- **Advantages:**
    - **Collision-free.**
    - **Perfectly fair:** Each node gets a dedicated rate of **R/N bps**.
- **Disadvantages:**
    - **Inefficient:** A node is limited to R/N bps **even if it is the only node with data to send**.
    - **Fixed Delay:** A node must always wait for its turn, even if the channel is idle. (INSERT FIGURE 6.9, TDM AND FDM EXAMPLE, HERE)

**2. Frequency-Division Multiplexing (FDM)**
- **Concept:** The channel's frequency spectrum is divided into **N different frequency bands**, each with a bandwidth of R/N. Each node is assigned its own dedicated frequency band.
- **Advantages & Disadvantages:** Shares the same pros and cons as TDM: collision-free and fair, but inefficient for a single active node (limited to R/N bps).

**3. Code Division Multiple Access (CDMA)**
- **Concept:** Assigns a **unique code** to each node. All nodes can transmit **simultaneously** over the entire frequency spectrum. A receiver can correctly decode a specific sender's data if it knows that sender's code, effectively filtering out other transmissions.
- **Use Cases:** Widely used in military systems (for anti-jamming) and in **cellular telephony**.
### **Random Access Protocols**
In random access protocols, a node transmits at the **full channel rate (R bps)** when it has data. If a **collision** occurs, the node waits a **random delay** before retransmitting. This avoids the channel waste of partitioning protocols when only one node is active.
#### **Slotted ALOHA**
This is a simple random access protocol with specific assumptions to make analysis easier.
**Assumptions:**
- Time is divided into equal **slots** (the size of one frame transmission time).
- Nodes are **synchronized** and can only start transmission at the beginning of a slot.
- All frames are the same size.
- Nodes can detect a collision before the slot ends.

**Protocol Operation:**
1. When a node has a new frame, it transmits at the beginning of the next slot.
2. If no collision occurs, the transmission is successful. The node is done.
3. If a collision occurs, the node detects it. The node then **retransmits the frame in each subsequent slot with probability `p`** until it is successful. (INSERT FIGURE 6.10, SLOTTED ALOHA OPERATION, HERE)

**Advantages:**
- **Single Active Node:** A single node can use the **full channel rate, R bps**.
- **Highly decentralized:** No central coordinator is needed.
- **Simple** to implement.

**Disadvantage: Efficiency**
- **Efficiency:** The long-run fraction of **successful slots** (slots where exactly one node transmits) when many nodes are active.
- **Analysis:** The maximum efficiency of slotted ALOHA is **1/e ≈ 0.37**.
- **Interpretation:** This means that at best, only **37% of the channel's capacity** is used for successful transmissions. The rest is wasted on **collisions (26%)** and **empty slots (37%)**.
### **ALOHA**
**Pure ALOHA (Unslotted ALOHA)**
- **Operation:** A fully decentralized protocol. When a frame first arrives, the node **immediately transmits** it in its entirety.
- **Collision Handling:** If a collision occurs, the node **immediately retransmits the frame with probability `p`** after the transmission is complete. Otherwise, it waits one frame transmission time and tries again.
- **Vulnerability Period:** For a frame starting at time `t₀` to be successful, no other node can start transmitting in the interval `[t₀ - 1, t₀ + 1]`. This is a **2-unit time** window. (INSERT FIGURE 6.11, INTERFERING TRANSMISSIONS IN PURE ALOHA, HERE)
- **Efficiency:** The maximum efficiency of pure ALOHA is **1/(2e) ≈ 0.18**. This is **half the efficiency of slotted ALOHA**, which is the price paid for being completely unslotted and decentralized.
### **Carrier Sense Multiple Access (CSMA)**
CSMA protocols introduce two simple, polite rules to reduce the chance of collisions, inspired by human conversation:
1. **Carrier Sensing: "Listen before speaking."** A node listens to the channel (**senses the carrier**) before transmitting. If the channel is busy, it waits.
2. **Collision Detection: "If someone else starts talking at the same time, stop talking."** A node listens to the channel **while it is transmitting**. If it detects that another node's transmission is interfering (a collision), it **stops transmitting** immediately.

**Why Do Collisions Still Occur in CSMA?**
- Due to **channel propagation delay**. A signal takes time to travel across the medium.
- **Scenario:** Node B starts transmitting. Its signal hasn't reached Node D yet. Node D senses the channel as idle and starts transmitting, leading to a collision. (INSERT FIGURE 6.12, CSMA WITH COLLIDING TRANSMISSIONS, HERE)
### **CSMA with Collision Detection (CSMA/CD)**
This is the protocol used in **Ethernet**. It combines carrier sensing with collision detection to improve efficiency by not wasting time transmitting corrupted frames in full.
**CSMA/CD Operation:**
1. The adapter gets a datagram and prepares a frame.
2. If the channel is idle, it starts transmitting. If busy, it waits until idle.
3. **While transmitting,** the adapter monitors the channel for collisions.
4. If the entire frame is transmitted without a collision, the process is done.
5. If a collision is detected **during transmission**, the adapter **immediately aborts** the transmission. (INSERT FIGURE 6.13, CSMA WITH COLLISION DETECTION, HERE)
6. After aborting, the adapter waits a **random** amount of time before returning to step 2.

**Binary Exponential Backoff:**
- This is the algorithm used to determine the random wait time after a collision. It ensures stability by adapting the wait time based on how many collisions a frame has experienced.
- **Algorithm:** After the *n*th collision, the adapter chooses a value **K** at random from the set `{0, 1, 2, ..., 2ⁿ-1}`. The wait time is **K × 512 bit times**.
- **Effect:** The **more collisions** a frame experiences, the **larger the range** from which K is chosen. This helps to separate the retransmission attempts of colliding nodes.
- The exponent `n` is capped (at 10 for Ethernet), so the wait time doesn't grow infinitely.
### **CASE HISTORY: Norm Abramson and ALOHAnet**
- Norm Abramson designed the **ALOHAnet** in Hawaii in 1969 to solve the problem of packet switching over radio across mountainous islands.
- This was the first example of a radio packet network.
- The **pure ALOHA** protocol was developed for this network to handle collisions on the shared upstream channel.
- ALOHAnet's design later **inspired Bob Metcalfe**, who modified it to create the **CSMA/CD protocol** and, ultimately, **Ethernet**.
### **CSMA/CD Efficiency**
The efficiency of CSMA/CD (as used in Ethernet) is defined as the long-run fraction of time the channel is used for **successful frame transmissions** without collisions.
- **Efficiency Formula:** `Efficiency = 1 / (1 + 5 * d_prop / d_trans)`
    - **`d_prop`:** The **maximum propagation delay** for a signal to travel between the two farthest nodes.
    - **`d_trans`:** The **time to transmit a maximum-size frame**.
**Interpretation:**
- If **`d_prop → 0`**, efficiency approaches **1**. With no propagation delay, collisions are detected instantly, and no channel capacity is wasted.
- If **`d_trans` becomes very large**, efficiency approaches **1**. A single frame holds the channel for a long time, making productive use of it.
### **Taking-Turns Protocols**
These protocols aim to provide the high efficiency of a single active node using the full rate (R bps) while also providing fair, collision-free access when multiple nodes are active (each getting ~R/M bps).

**1. Polling Protocol:**
- **Operation:** A designated **master node** polls the other nodes in a round-robin fashion. It asks each node in turn if it has data to send, granting it permission to transmit up to a maximum number of frames.
- **Advantages:**
    - **Eliminates collisions and empty slots**, leading to high efficiency.
- **Disadvantages:**
    - **Polling Delay:** The time spent notifying nodes introduces latency.
    - **Single Point of Failure:** If the master node fails, the entire network fails.
    - **Example:** Bluetooth.

**2. Token-Passing Protocol:**
- **Operation:** A special frame called a **token** is passed from node to node in a fixed, circular order. A node can only transmit when it is holding the token.
- **Advantages:**
    - **Decentralized** (no master node).
    - **Highly efficient** and collision-free.
- **Disadvantages:**
    - **Token Loss:** If a node fails, the token can be lost, crashing the network.
    - **Token Holding:** A faulty or malicious node might hold the token indefinitely.
    - **Examples:** FDDI, IEEE 802.5 Token Ring.
### **DOCSIS: The Link-Layer Protocol for Cable Internet Access**
DOCSIS is the protocol used in cable internet access networks. It provides a fascinating **case study** because it combines elements from **all three classes** of multiple access protocols.
**Network Context:**
- The **Cable Modem Termination System (CMTS)** at the headend communicates with thousands of residential **cable modems**.
- **Downstream (CMTS → Modems):** A pure broadcast channel from a single sender (the CMTS), so no multiple access problem.
- **Upstream (Modems → CMTS):** A shared broadcast channel where multiple modems can transmit, requiring a multiple access protocol.

**How DOCSIS Works (Upstream Channel):** (INSERT FIGURE 6.14, DOCSIS UPSTREAM AND DOWNSTREAM, HERE)
1. **TDM-like Structure:** The upstream channel is divided into time intervals containing **mini-slots**.
2. **Centralized Allocation (Taking-Turns):** The CMTS sends a **MAP message** (downstream) to explicitly grant specific mini-slots to specific cable modems for data transmission. This **prevents collisions** for data frames.
3. **Random Access for Requests:** To tell the CMTS it has data to send, a modem transmits a **mini-slot-request frame** during a special set of mini-slots reserved for this purpose. These requests are sent using a **random access** method and **can collide**.
4. **Collision Handling:** Modems cannot sense the channel. They infer a collision if they don't receive a grant in response to their request. They then use **binary exponential backoff** to retransmit the request.

**Summary:** DOCSIS is a hybrid protocol using:
- **FDM** to create separate upstream/downstream channels.
- **TDM** to structure the upstream channel into mini-slots.
- **Taking-Turns** for collision-free data transmission via central allocation.
- **Random Access** with binary exponential backoff for initial bandwidth requests.

### **Switched Local Area Networks**
**Core Concept:** A network where hosts and routers are connected by **link-layer switches**. These switches operate at the link layer, forwarding **frames** (not datagrams) based on **MAC addresses**, not IP addresses.
### **Link-Layer Addressing and ARP**
#### **MAC Addresses**
- **What they are:** A unique, 6-byte (48-bit) identifier assigned to a device's network adapter (interface).
    - Also called a **LAN address**, **physical address**, or **MAC address**.
- **Key Properties:**
    1. **Flat Structure:** Unlike hierarchical IP addresses, a MAC address does not change, no matter where the device connects.
    2. **Globally Unique:** Managed by IEEE, which allocates blocks of addresses (first 24 bits) to manufacturers.
- **Analogy:**
    - **MAC Address:** Like a Social Security Number (flat, permanent).
    - **IP Address:** Like a postal address (hierarchical, changes with location).
- **Frame Handling:** An adapter only processes a frame and passes the datagram up the protocol stack if the frame's destination MAC address matches its own or is the **broadcast address** (`FF-FF-FF-FF-FF-FF`).
#### **Why Both IP and MAC Addresses? (Layered Independence)**
1. **Protocol Neutrality:** LANs must support various network-layer protocols (IP, IPX), not just IP.
2. **Independence:** To keep layers as independent building blocks, each needs its own addressing scheme.
#### **Address Resolution Protocol (ARP)**
- **Purpose:** To resolve a **network-layer IP address** to a **link-layer MAC address** for a destination on the **same subnet**.
- **Analogy:** ARP is to IP/MAC resolution as **DNS** is to hostname/IP resolution, but ARP only works within a local subnet.

**How ARP Works:**
1. **ARP Table:** Each host and router maintains a table that maps IP addresses to MAC addresses. Each entry has a **Time-To-Live (TTL)**.
2. **The ARP Process:**
    - A sending host checks its ARP table for the destination IP address.
    - If the mapping **exists**, it uses the MAC address to send the frame.
    - If the mapping **does not exist**, it initiates an ARP query:
        - **Query:** The sender creates an **ARP query packet** and sends it inside a **broadcast frame** (destination MAC = `FF-FF-FF-FF-FF-FF`) to all devices on the subnet.
        - **Response:** The device whose IP address matches the query responds by sending an **ARP response packet** back to the sender inside a **standard, unicast frame**.
    - The sender receives the response, updates its ARP table, and can now send the original data frame.

- **Key Characteristics of ARP:**
    - **Plug-and-Play:** ARP tables are built automatically; no manual configuration is needed.
    - **Architectural Placement:** ARP straddles the boundary between the link and network layers, as it uses link-layer framing but contains network-layer addresses.
### **Sending a Datagram Off the Subnet**
**The Scenario:** A host needs to send a datagram to a destination on a **different subnet**. This requires traversing a router.
**Key Insight:** The host does **not** use the final destination's MAC address. Instead, it uses the MAC address of the **first-hop router** (the "default gateway").

**The Process (using Figure 6.19 as an example):**

1. **Host Decision:** Host 111.111.111.111 determines that the destination (222.222.222.222) is on a different network.
    
2. **First Hop:** The host concludes it must send the datagram to its configured **router interface** (111.111.111.110).
    
3. **ARP for Router:** The host uses **ARP** to find the **MAC address** of the router interface 111.111.111.110.
    
4. **Frame to Router:** The host creates a frame with the **destination MAC address of the router** but the **destination IP address of the final host**. It sends this frame.
    
5. **Router's Job:** The router's adapter receives the frame, passes the IP datagram up, and the router's network layer consults its forwarding table.
    
6. **Second Hop:** The forwarding table dictates the datagram should be sent out the interface with IP 222.222.222.220.
    
7. **ARP for Final Host:** The router's second interface uses **ARP** to find the **MAC address** of the final destination host (222.222.222.222).
    
8. **Final Delivery:** The router creates a _new_ frame with the **destination MAC address of the final host** and sends it onto Subnet 2.
    

### **Ethernet**

**Dominance:** Ethernet is the dominant wired LAN technology due to its early deployment, simplicity, low cost, and constant evolution to higher data rates.

**Evolution of Topology:**

- **Past:** Bus topology (coaxial cable), which was a broadcast LAN.
    
- **Then:** Star topology with a **hub**. A hub is a physical-layer device that repeats bits to all other ports, making it also a **broadcast LAN** where collisions occur.
    
- **Now:** Star topology with a **switch**. A switch is a link-layer device that is "collision-less" and can forward frames intelligently.
    

#### **Ethernet Frame Structure**

The Ethernet frame has several key fields:

- **Preamble (8 bytes):** The first 7 bytes (10101010) synchronize the receiver's clock. The last byte (10101011) alerts the receiver that the frame is starting.
    
- **Destination Address (6 bytes):** The MAC address of the destination adapter.
    
- **Source Address (6 bytes):** The MAC address of the sending adapter.
    
- **Type Field (2 bytes):** Essential for **multiplexing/demultiplexing**. It indicates which network-layer protocol (e.g., IP, ARP) is contained in the data field. This is the link-layer equivalent of the transport-layer port number or network-layer protocol field.
    
- **Data Field (46 to 1,500 bytes):** Carries the IP datagram (or other network-layer packet). This defines the Ethernet **MTU (Maximum Transmission Unit)**. If the data is less than 46 bytes, it is "stuffed" to meet the minimum.
    
- **CRC (Cyclic Redundancy Check) (4 bytes):** Used for **error detection**. The receiving adapter discards the frame if an error is detected.
    

#### **Ethernet Services**

- **Connectionless:** No handshake is performed before sending a frame.
    
- **Unreliable:** The receiving adapter does **not** send acknowledgments for correctly received frames. It simply discards frames that fail the CRC check.
    

**Implication for Higher Layers:**

- If a frame is dropped, there is no Ethernet-level retransmission.
    
- **UDP:** The application would see a gap in the data.
    
- **TCP:** TCP would notice the missing data (via lack of ACK) and retransmit it. The retransmitted data would be sent in a new Ethernet frame, so reliability is achieved at a higher layer.